// Code generated by MockGen. DO NOT EDIT.
// Source: ./pkg/codegraph/store/storage.go

// Package mocks is a generated GoMock package.
package mocks

import (
	store "codebase-indexer/pkg/codegraph/store"
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	proto "google.golang.org/protobuf/proto"
)

// MockGraphStorage is a mock of GraphStorage interface.
type MockGraphStorage struct {
	ctrl     *gomock.Controller
	recorder *MockGraphStorageMockRecorder
}

// MockGraphStorageMockRecorder is the mock recorder for MockGraphStorage.
type MockGraphStorageMockRecorder struct {
	mock *MockGraphStorage
}

// NewMockGraphStorage creates a new mock instance.
func NewMockGraphStorage(ctrl *gomock.Controller) *MockGraphStorage {
	mock := &MockGraphStorage{ctrl: ctrl}
	mock.recorder = &MockGraphStorageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGraphStorage) EXPECT() *MockGraphStorageMockRecorder {
	return m.recorder
}

// BatchSave mocks base method.
func (m *MockGraphStorage) BatchSave(ctx context.Context, projectUuid string, values store.Entries) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BatchSave", ctx, projectUuid, values)
	ret0, _ := ret[0].(error)
	return ret0
}

// BatchSave indicates an expected call of BatchSave.
func (mr *MockGraphStorageMockRecorder) BatchSave(ctx, projectUuid, values interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchSave", reflect.TypeOf((*MockGraphStorage)(nil).BatchSave), ctx, projectUuid, values)
}

// Close mocks base method.
func (m *MockGraphStorage) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockGraphStorageMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockGraphStorage)(nil).Close))
}

// Delete mocks base method.
func (m *MockGraphStorage) Delete(ctx context.Context, projectUuid string, key store.Key) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, projectUuid, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockGraphStorageMockRecorder) Delete(ctx, projectUuid, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockGraphStorage)(nil).Delete), ctx, projectUuid, key)
}

// Get mocks base method.
func (m *MockGraphStorage) Get(ctx context.Context, projectUuid string, key store.Key) (proto.Message, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, projectUuid, key)
	ret0, _ := ret[0].(proto.Message)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockGraphStorageMockRecorder) Get(ctx, projectUuid, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockGraphStorage)(nil).Get), ctx, projectUuid, key)
}

// Iter mocks base method.
func (m *MockGraphStorage) Iter(ctx context.Context, projectUuid string) store.Iterator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Iter", ctx, projectUuid)
	ret0, _ := ret[0].(store.Iterator)
	return ret0
}

// Iter indicates an expected call of Iter.
func (mr *MockGraphStorageMockRecorder) Iter(ctx, projectUuid interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Iter", reflect.TypeOf((*MockGraphStorage)(nil).Iter), ctx, projectUuid)
}

// Save mocks base method.
func (m *MockGraphStorage) Save(ctx context.Context, projectUuid string, value proto.Message) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Save", ctx, projectUuid, value)
	ret0, _ := ret[0].(error)
	return ret0
}

// Save indicates an expected call of Save.
func (mr *MockGraphStorageMockRecorder) Save(ctx, projectUuid, value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockGraphStorage)(nil).Save), ctx, projectUuid, value)
}

// Size mocks base method.
func (m *MockGraphStorage) Size(ctx context.Context, projectUuid string) int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Size", ctx, projectUuid)
	ret0, _ := ret[0].(int)
	return ret0
}

// Size indicates an expected call of Size.
func (mr *MockGraphStorageMockRecorder) Size(ctx, projectUuid interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Size", reflect.TypeOf((*MockGraphStorage)(nil).Size), ctx, projectUuid)
}

// MockIterator is a mock of Iterator interface.
type MockIterator struct {
	ctrl     *gomock.Controller
	recorder *MockIteratorMockRecorder
}

// MockIteratorMockRecorder is the mock recorder for MockIterator.
type MockIteratorMockRecorder struct {
	mock *MockIterator
}

// NewMockIterator creates a new mock instance.
func NewMockIterator(ctrl *gomock.Controller) *MockIterator {
	mock := &MockIterator{ctrl: ctrl}
	mock.recorder = &MockIteratorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIterator) EXPECT() *MockIteratorMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockIterator) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockIteratorMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockIterator)(nil).Close))
}

// Error mocks base method.
func (m *MockIterator) Error() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Error")
	ret0, _ := ret[0].(error)
	return ret0
}

// Error indicates an expected call of Error.
func (mr *MockIteratorMockRecorder) Error() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockIterator)(nil).Error))
}

// Key mocks base method.
func (m *MockIterator) Key() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Key")
	ret0, _ := ret[0].(string)
	return ret0
}

// Key indicates an expected call of Key.
func (mr *MockIteratorMockRecorder) Key() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Key", reflect.TypeOf((*MockIterator)(nil).Key))
}

// Next mocks base method.
func (m *MockIterator) Next() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Next")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Next indicates an expected call of Next.
func (mr *MockIteratorMockRecorder) Next() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockIterator)(nil).Next))
}

// Value mocks base method.
func (m *MockIterator) Value() proto.Message {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Value")
	ret0, _ := ret[0].(proto.Message)
	return ret0
}

// Value indicates an expected call of Value.
func (mr *MockIteratorMockRecorder) Value() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Value", reflect.TypeOf((*MockIterator)(nil).Value))
}

// MockKey is a mock of Key interface.
type MockKey struct {
	ctrl     *gomock.Controller
	recorder *MockKeyMockRecorder
}

// MockKeyMockRecorder is the mock recorder for MockKey.
type MockKeyMockRecorder struct {
	mock *MockKey
}

// NewMockKey creates a new mock instance.
func NewMockKey(ctrl *gomock.Controller) *MockKey {
	mock := &MockKey{ctrl: ctrl}
	mock.recorder = &MockKeyMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockKey) EXPECT() *MockKeyMockRecorder {
	return m.recorder
}

// Get mocks base method.
func (m *MockKey) Get() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get")
	ret0, _ := ret[0].(string)
	return ret0
}

// Get indicates an expected call of Get.
func (mr *MockKeyMockRecorder) Get() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockKey)(nil).Get))
}

// MockValues is a mock of Entries interface.
type MockValues struct {
	ctrl     *gomock.Controller
	recorder *MockValuesMockRecorder
}

// MockValuesMockRecorder is the mock recorder for MockValues.
type MockValuesMockRecorder struct {
	mock *MockValues
}

// NewMockValues creates a new mock instance.
func NewMockValues(ctrl *gomock.Controller) *MockValues {
	mock := &MockValues{ctrl: ctrl}
	mock.recorder = &MockValuesMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockValues) EXPECT() *MockValuesMockRecorder {
	return m.recorder
}

// Key mocks base method.
func (m *MockValues) Key(i int) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Key", i)
	ret0, _ := ret[0].(string)
	return ret0
}

// Key indicates an expected call of Key.
func (mr *MockValuesMockRecorder) Key(i interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Key", reflect.TypeOf((*MockValues)(nil).Key), i)
}

// Len mocks base method.
func (m *MockValues) Len() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Len")
	ret0, _ := ret[0].(int)
	return ret0
}

// Len indicates an expected call of Len.
func (mr *MockValuesMockRecorder) Len() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Len", reflect.TypeOf((*MockValues)(nil).Len))
}

// Value mocks base method.
func (m *MockValues) Value(i int) proto.Message {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Value", i)
	ret0, _ := ret[0].(proto.Message)
	return ret0
}

// Value indicates an expected call of Value.
func (mr *MockValuesMockRecorder) Value(i interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Value", reflect.TypeOf((*MockValues)(nil).Value), i)
}
